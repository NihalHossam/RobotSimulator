// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package main.java.softdesign;
import java.awt.Color;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import javax.vecmath.Point3d;
import javax.vecmath.Vector3d;
import simbad.sim.*;

/************************************************************/
/*Robot class responsible for exploring the environment and searching for boxes of target color*/
public class Robot extends Agent implements Observer{
	
	/*speed with which robots move in the environment*/
	public final static double SPEED = 0.5d;
	
	/*if amount of black pixels in the picture exceeds this value, it means that the 
	 * camera installed on board the robot is broken */
	public final static int BROKENCAMERA = 9000;
	
	/*if amount of pixels in the picture exceeds this value, it means that the
	 * target box is detected*/
	public final static int COLORPIXEL = 2000;
	
	/*direction to follow which is received from Central Station in case it is stuck in the environment*/
	private Direction orderedDirection;
	
	/*default value - NOERROR, meaning that the robot's system are functioning without faults*/
	private RobotStatus robotStatus;
	
	/*robot's current position in the environment */
	private Position currentLocation;
	
	/*record current status of task to control the movement*/
	private TaskStatus taskStatus;
	
	/*color of the target box*/
	private Color targetColor;
	
	/*list containing positions in the environment that have been covered by the robot*/
	private HashMap<Position, double[]> coveredArea = new HashMap<Position, double[]>();
	
	/*singleton instance of Central Station*/
	public CentralStation centralStation = CentralStation.getInstance();
	
	/*instance of the task object*/
	public Task task;
	
	/*technical attributes necessary for executing the mission */
    private RangeSensorBelt sonar;
	private CameraSensor camera;
	
	/*moving status: going around randomly or detecting obstacle and avoiding it*/
    private String currentMode;
	
    /*constructor for Robot class */
	public Robot(String name, Vector3d initialPosition, Direction orderedDirection){
		super(initialPosition, name);
		this.currentLocation = new Position(initialPosition.getX(), initialPosition.getZ());
		this.orderedDirection = orderedDirection;
		this.sonar = RobotFactory.addSonarBeltSensor(this, 8);
        this.camera = RobotFactory.addCameraSensor(this);
        this.robotStatus = RobotStatus.NOERROR;
	}
	
	/**
	 * NEW method
	 * this method performs every 5 virtual seconds
	 * without this the robot cannot move at all
	 */
	public void performBehavior() {
    	if(this.getCounter() % 5 == 0) {
    		if(taskStatus == TaskStatus.COMPLETED || taskStatus == TaskStatus.FAILED) {
    			this.setTranslationalVelocity(0);
    			this.setRotationalVelocity(0);
    			this.reset();
    			return;
    		}
			this.saveCurrentLocation();
			if(this.getCounter() % 200 == 0 && this.getCounter() != 0){
				this.sendMapMessage();
			}
	    	if(sonar.getFrontQuadrantMeasurement()<0.7) {
	    		this.currentMode = "detectObstacle";
	    	} else if (this.collisionDetected()){
	    		this.currentMode = "avoidObstacle";
	    	} else {
	    		this.currentMode = "goAround";
	    	}
	        
	    	if(this.currentMode == "goAround") {
	    		// the robot's speed is always 0.5 m/s
	    		this.setRotationalVelocity(0);
	            this.setTranslationalVelocity(SPEED);
	    		// frequently change orientation
	            if ((getCounter() % 100) == 0) {
	            	this.setRotationalVelocity(Math.PI / 4 * (0.5 - Math.random()));
	            }
	        } else if(this.currentMode == "detectObstacle"){
	        	// don't move
	        	this.setTranslationalVelocity(0);
	        	this.takePhoto();
	        	setRotationalVelocity(Math.PI / 2);
	        } else {
	        	this.setTranslationalVelocity(0);
	        	setRotationalVelocity(Math.PI / 2);
	        }
    	}
    }
	/*sends report to Central Station containing covered positions in the environment*/
	public void sendMapMessage() {
		MessageFactory mf = MessageFactory.getInstance();
		MapMessage mapmessage = (MapMessage) mf.getMessage("MAP");
		mapmessage.setSearchedAreas(coveredArea);
		mapmessage.setRobotID(name);
		centralStation.handleMessage(mapmessage);
	}

	/*sends to Central Station the photograph and location of the found target box*/
	public void sendBoxMessage(Position boxLocation, BufferedImage boxPhoto) {
		MessageFactory mf = MessageFactory.getInstance();
		BoxMessage boxmessage = (BoxMessage) mf.getMessage("BOX");
		boxmessage.saveBoxLocation(boxLocation);
		boxmessage.saveBoxPhoto(boxPhoto);
		centralStation.handleMessage(boxmessage);
	}

	/** new method to attach robot to the observer list*/
	public void receiveTask(Task task) {
		this.task = task;
		task.attach(this);
		this.taskStatus = task.getTaskStatus();
		this.targetColor = task.getBoxColor();
	}
	
	/*realization of Observer design pattern: updating internal parameters as soon as status of
	 * the Subject has been changed */
	public void update() {
		this.targetColor = task.getBoxColor();
		this.taskStatus = task.getTaskStatus();
	}

	/*taking the photograph of the obstacle encountered by the robot 
	 * and determining whether it is the target box or not*/
	public void takePhoto() {
		BufferedImage photo = new BufferedImage(100,100,BufferedImage.TYPE_INT_RGB);
		camera.copyVisionImage(photo);
		int width = photo.getWidth();
        int height = photo.getHeight();
        int pixel=0;
        int blackPixel = 0;
        for(int i=0; i<width; i++) {
        	for(int j=0; j<height; j++) {
            	Color mycolor = new Color(photo.getRGB(i, j));
            	if(targetColor.getRGB()==mycolor.getRGB()) {
            		pixel++;
            	}
            	if(mycolor.getRGB()==Color.BLACK.getRGB()) {
            		//if the pixel is black, blackPixel++
            		//this is to detect whether there is something
            		//wrong with the camera
            		blackPixel++;
            	}
        	}
        }
        if(pixel>COLORPIXEL) {
            /**
             * more than COLORPIXEL(constant value = 1000) pixel inside the 100*100 bufferedImage is has the target
             * color, we should consider it as 'there is a box inside the picture'
           	 */
            this.sendBoxMessage(this.calculateBoxLocation(), photo);
        } else if (blackPixel>=BROKENCAMERA) {
        	//if half of the picture is black
        	//we can assume that the camera is broken
        	this.robotStatus = RobotStatus.CAMERAFAULT;
        	this.sendErrorMessage();
        }
	}

	/**
	 * get the four different directions' sonar infomation
	 * to update the coveredArea hashmap
	 * which will be used to create mapmessage
	 * change to no parameter 
	 */
	public void saveCurrentLocation() {
		double sensorData[] = {0,0,0,0};
		sonar.getSensorAngle(1);
		sensorData[0] = (sonar.getBackQuadrantMeasurement()<=1.5)? sonar.getBackQuadrantMeasurement():1.5;
		sensorData[1] = (sonar.getLeftQuadrantMeasurement()<=1.5)? sonar.getLeftQuadrantMeasurement():1.5;
		sensorData[2] = (sonar.getFrontQuadrantMeasurement()<=1.5)? sonar.getFrontQuadrantMeasurement():1.5;
		sensorData[3] = (sonar.getRightQuadrantMeasurement()<=1.5)? sonar.getRightQuadrantMeasurement():1.5;
		coveredArea.put(this.updateCurrentLocation(),sensorData);
	}

	/*sends error report to Central Station in case of hardware fault */
	public void sendErrorMessage() {
		MessageFactory mf = MessageFactory.getInstance();
		ErrorMessage message = (ErrorMessage) mf.getMessage("ERROR");
		message.setRobotID(getName());
		message.setRobotStatus(robotStatus);
		message.setRobotLocation(currentLocation);
		centralStation.handleMessage(message);
	}

	/*receives new directions to follow from Central Station*/
	public void setOrderedDirection(Direction orderedDirection) {
		this.orderedDirection = orderedDirection;
	}

	/**
	 * update the robot's current location in the environment */
	public Position updateCurrentLocation() {
		Point3d loc = new Point3d();
		this.getCoords(loc);
		this.currentLocation = new Position(loc.getX(),loc.getZ());
		return currentLocation;
	}
	/**Heuristic to measure the position of the found target box.
	 * Because the robot only stop to take a picture when there is something
	 * in front of itself, we can simply substract the value of front quadrant
	 * measurement of the sensor from the robot's current location. */
	public Position calculateBoxLocation() {
		Double distance = sonar.getFrontQuadrantMeasurement();
		Point3d loc = new Point3d();
		this.getCoords(loc);
		Position boxLocation = new Position(loc.getX()-distance, loc.getZ());
		return boxLocation;
	}
};
